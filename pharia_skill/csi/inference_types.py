from dataclasses import dataclass
from typing import Annotated, Any, Self

from pydantic import BeforeValidator, field_validator


def none_to_nan(v: float | None) -> float:
    """Custom deserialization for Nan.

    This custom deserialization is necessary because JSON does not support NaN (Not a Number)
    values as valid data types, as specified by the JSON standard.
    """

    return float("nan") if v is None else v


NanFloat = Annotated[float, BeforeValidator(none_to_nan)]


@dataclass
class Logprob:
    """Logarithmic probability of the token returned in the completion."""

    token: bytes
    logprob: NanFloat

    @field_validator("token", mode="before")
    @classmethod
    def convert_token_to_bytes(cls, v: Any) -> Any:
        if isinstance(v, list):
            return bytes(v)
        return v

    def try_as_utf8(self) -> str | None:
        """Try to decode the token as utf-8.

        A token may also represent just a part of an utf-8 character, in which
        case it does not have a valid utf-8 encoding on its own.
        """
        try:
            return self.token.decode("utf-8")
        except UnicodeDecodeError:
            return None


@dataclass
class Distribution:
    sampled: Logprob
    top: list[Logprob]

    @classmethod
    def from_dict(cls, body: dict[str, Any]) -> "Distribution":
        raise NotImplementedError(
            "Not implemented, maybe look into pydantic dataclasses"
        )


@dataclass
class MessageAppend:
    """A chunk of a message generated by the model.

    Attributes:
        content (str, required): A chunk of the message content.
        logprobs (list[Distribution], required): Corresponding log probabilities for each token in the message content.
    """

    content: str
    logprobs: list[Distribution]

    @classmethod
    def from_dict(cls, body: dict[str, Any]) -> Self:
        return cls(
            content=body["content"],
            logprobs=body["logprobs"],
        )
