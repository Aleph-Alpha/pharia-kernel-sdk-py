import json
import typing
from enum import Enum
from typing import Annotated, Any, Self

from pydantic import BeforeValidator, field_serializer, field_validator
from pydantic.dataclasses import dataclass

# We don't want to make opentelemetry a dependency of the wasm module
if typing.TYPE_CHECKING:
    from opentelemetry.util.types import AttributeValue


def none_to_nan(v: float | None) -> float:
    """Custom deserialization for Nan.

    This custom deserialization is necessary because JSON does not support NaN (Not a Number)
    values as valid data types, as specified by the JSON standard.
    """

    return float("nan") if v is None else v


NanFloat = Annotated[float, BeforeValidator(none_to_nan)]


@dataclass
class Logprob:
    """Logarithmic probability of the token returned in the completion."""

    token: bytes
    logprob: NanFloat

    @field_validator("token", mode="before")
    @classmethod
    def convert_token_to_bytes(cls, v: Any) -> Any:
        if isinstance(v, list):
            return bytes(v)
        return v

    def try_as_utf8(self) -> str | None:
        """Try to decode the token as utf-8.

        A token may also represent just a part of an utf-8 character, in which
        case it does not have a valid utf-8 encoding on its own.
        """
        try:
            return self.token.decode("utf-8")
        except UnicodeDecodeError:
            return None


@dataclass
class Distribution:
    sampled: Logprob
    top: list[Logprob]

    @classmethod
    def from_dict(cls, body: dict[str, Any]) -> "Distribution":
        raise NotImplementedError(
            "Not implemented, maybe look into pydantic dataclasses"
        )


@dataclass
class MessageAppend:
    """A chunk of a message generated by the model.

    Attributes:
        content (str, required): A chunk of the message content.
        logprobs (list[Distribution], required): Corresponding log probabilities for each token in the message content.
    """

    content: str
    logprobs: list[Distribution]

    @classmethod
    def from_dict(cls, body: dict[str, Any]) -> Self:
        return cls(
            content=body["content"],
            logprobs=body["logprobs"],
        )


class Role(str, Enum):
    """A role used for a message in a chat."""

    User = "user"
    Developer = "developer"
    Assistant = "assistant"
    System = "system"
    Tool = "tool"


@dataclass
class MessageBegin:
    role: str


@dataclass
class TokenUsage:
    """Usage statistics for the completion request."""

    prompt: int
    completion: int

    def as_gen_ai_otel_attributes(self) -> dict[str, int]:
        """The attributes specified by the GenAI Otel Semantic convention.

        See <https://opentelemetry.io/docs/specs/semconv/registry/attributes/gen-ai/#genai-attributes>
        for more details.
        """
        return {
            "gen_ai.usage.input_tokens": self.prompt,
            "gen_ai.usage.output_tokens": self.completion,
        }


class FinishReason(str, Enum):
    """The reason the model finished generating.

    Attributes:
        STOP: The model hit a natural stopping point or a provided stop sequence.

        LENGTH: The maximum number of tokens specified in the request was reached.

        CONTENT_FILTER: Content was omitted due to a flag from content filters.

        TOOL_CALLS: The model called a tool.
    """

    STOP = "stop"
    LENGTH = "length"
    CONTENT_FILTER = "content_filter"
    TOOL_CALLS = "tool_calls"

    def as_gen_ai_otel_attributes(self) -> dict[str, "AttributeValue"]:
        """How to format the finish reason as a GenAI attribute.

        The OTel spec specifies two possibilities: Either including it in the message
        (`gen_ai.output.messages.0.finish_reason`) or as a separate field on the
        response (`gen_ai.response.finish_reason`). Langfuse get's a bit confused by
        the first option, so we use the second.
        """
        return {"gen_ai.response.finish_reasons": [self.value]}


@dataclass
class ToolCallChunk:
    """A tool call chunk."""

    index: int
    """The index of the chunk w.r.t. to the other tool calls in the same message."""

    id: str | None = None
    """The ID of the tool call."""

    name: str | None = None
    """The name of the tool to call."""

    arguments: str | None = None
    """The arguments to call the function with, as generated by the model in JSON format.
    Note that the model does not always generate valid JSON, and may hallucinate parameters
    not defined by your function schema. Validate the arguments in your code before calling
    your function."""


@dataclass
class ToolCall:
    id: str
    name: str
    arguments: dict[str, Any]

    @field_serializer("arguments")
    def serialize_arguments(self, arguments: dict[str, Any]) -> str:
        return json.dumps(arguments)

    def as_message(self) -> "Message":
        """Render the tool call request from the model to a message."""
        return Message.assistant(
            content=None,
            tool_calls=[self],
        )


@dataclass
class ToolCallEvent:
    """A list of tool call chunks."""

    tool_calls: list[ToolCallChunk]


def merge_tool_call_chunks(events: list[ToolCallEvent]) -> list[ToolCall]:
    """Merge a list of tool call chunks to a list of tool calls.

    Each `ToolCallChunks` contains parts of of one multiple tool calls. If the models
    response contains multiple tool calls, the first `ToolCallChunks` could e.g. contain
    the name of the first and second tool call, while the second `ToolCallChunks` could
    contain the arguments of the first and second tool call.

    This function merges the chunks into a list of tool calls.
    """

    @dataclass
    class InProgressToolCall:
        id: str
        name: str
        arguments: str

        @classmethod
        def from_chunk(cls, chunk: ToolCallChunk) -> Self:
            assert chunk.id is not None, "expected first chunk to have an id"
            assert chunk.name is not None, "expected first chunk to have a name"

            return cls(
                id=chunk.id,
                name=chunk.name,
                arguments=chunk.arguments or "",
            )

        def extend(self, chunk: ToolCallChunk) -> None:
            if chunk.name is not None:
                self.name += chunk.name
            if chunk.arguments is not None:
                self.arguments += chunk.arguments

        def as_tool_call(self) -> ToolCall:
            return ToolCall(
                id=self.id, name=self.name, arguments=json.loads(self.arguments)
            )

    if not events:
        return []

    in_progress: dict[int, InProgressToolCall] = {
        event.index: InProgressToolCall.from_chunk(event)
        for event in events[0].tool_calls
    }
    for event in events[1:]:
        for chunk in event.tool_calls:
            in_progress[chunk.index].extend(chunk)

    return list(map(InProgressToolCall.as_tool_call, in_progress.values()))


ChatEvent = MessageBegin | MessageAppend | FinishReason | TokenUsage | ToolCallEvent


@dataclass
class Message:
    """A single turn in a conversation.

    Parameters:
        role (Role, required): The role of the message.
        content (str, required): The content of the message.
    """

    role: Role
    content: str | None
    tool_calls: list[ToolCall] | None = None
    tool_call_id: str | None = None

    def as_gen_ai_otel_attributes(self) -> dict[str, Any]:
        """Format as specified by OpenTelemetry GenAI semantic conventions.

        See <https://opentelemetry.io/docs/specs/semconv/registry/attributes/gen-ai/#genai-attributes>
        for more details.
        """
        return {
            "role": self.role.value,
            # While `parts` is required by the OTel specification, Langfuse only renders
            # text content properly if passed as `content`.
            "content": self.content,
        }

    @classmethod
    def user(cls, content: str) -> Self:
        return cls(role=Role.User, content=content)

    @classmethod
    def assistant(
        cls, content: str | None, tool_calls: list[ToolCall] | None = None
    ) -> Self:
        assert content is not None or tool_calls is not None, (
            "either content or tool_calls must be provided"
        )
        return cls(role=Role.Assistant, content=content, tool_calls=tool_calls)

    @classmethod
    def system(cls, content: str) -> Self:
        return cls(role=Role.System, content=content)

    @classmethod
    def tool(cls, content: str, tool_call_id: str) -> Self:
        return cls(role=Role.Tool, content=content, tool_call_id=tool_call_id)

    @classmethod
    def from_dict(cls, body: dict[str, Any]) -> Self:
        # the shell csi does not serialize the roles in lowercase
        role = Role(body["role"].lower())
        content = body["content"]
        tool_calls = body["tool_calls"]
        tool_call_id = body["tool_call_id"]
        return cls(
            role=role, content=content, tool_calls=tool_calls, tool_call_id=tool_call_id
        )
