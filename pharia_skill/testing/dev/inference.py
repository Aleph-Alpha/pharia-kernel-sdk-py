from enum import Enum

from pydantic import BaseModel, RootModel, TypeAdapter
from sseclient import Event

from pharia_skill.csi.inference import ChatEvent as csi_ChatEvent
from pharia_skill.csi.inference import (
    ChatEvent_MessageAppend,
    ChatEvent_MessageBegin,
    ChatEvent_MessageEnd,
    ChatEvent_Usage,
    ChatParams,
    ChatRequest,
    ChatResponse,
    Completion,
    CompletionAppend,
    CompletionEvent_Append,
    CompletionEvent_End,
    CompletionEvent_Usage,
    CompletionParams,
    CompletionRequest,
    ExplanationRequest,
    FinishReason,
    Message,
    MessageAppend,
    TextScore,
    TokenUsage,
)
from pharia_skill.csi.inference import CompletionEvent as csi_CompletionEvent


class CompletionEvent(str, Enum):
    """An event emitted by a completion stream.

    Attributes:
        APPEND: A chunk of a completion returned by a completion stream.

        END: The reason the completion stream stopped.

        USAGE: The usage generated by the completion stream.
    """

    APPEND = "append"
    END = "end"
    USAGE = "usage"


class ChatEvent(str, Enum):
    """An event emitted by the chat-stream resource.

    Attributes:
        MESSAGE_BEGIN: The start of a new message. It includes the role of the message.

        MESSAGE_APPEND: A chunk of a message generated by the model.

        MESSAGE_END: The end of a message. It includes the reason for the message end.

        USAGE: The usage from the generated message
    """

    MESSAGE_BEGIN = "message_begin"
    MESSAGE_APPEND = "message_append"
    MESSAGE_END = "message_end"
    USAGE = "usage"


def completion_event_from_sse(event: Event) -> csi_CompletionEvent:
    match event.event:
        case CompletionEvent.APPEND:
            append = TypeAdapter(CompletionAppend).validate_json(event.data)
            return CompletionEvent_Append(append)
        case CompletionEvent.END:
            finish_reason = (
                TypeAdapter(FinishReasonDeserializer)
                .validate_json(event.data)
                .finish_reason
            )
            return CompletionEvent_End(finish_reason)
        case CompletionEvent.USAGE:
            usage = TypeAdapter(TokenUsageDeserializer).validate_json(event.data).usage
            return CompletionEvent_Usage(usage)
    raise ValueError(f"unknown event type: {event.event}")


def chat_event_from_sse(event: Event) -> csi_ChatEvent:
    match event.event:
        case ChatEvent.MESSAGE_BEGIN:
            role = TypeAdapter(RoleDeserializer).validate_json(event.data).role
            return ChatEvent_MessageBegin(role)
        case ChatEvent.MESSAGE_APPEND:
            append = TypeAdapter(MessageAppend).validate_json(event.data)
            return ChatEvent_MessageAppend(append)
        case ChatEvent.MESSAGE_END:
            finish_reason = (
                TypeAdapter(FinishReasonDeserializer)
                .validate_json(event.data)
                .finish_reason
            )
            return ChatEvent_MessageEnd(finish_reason)
        case ChatEvent.USAGE:
            usage = TypeAdapter(TokenUsageDeserializer).validate_json(event.data).usage
            return ChatEvent_Usage(usage)
    raise ValueError(f"unknown event type: {event.event}")


class FinishReasonDeserializer(BaseModel):
    finish_reason: FinishReason


class TokenUsageDeserializer(BaseModel):
    usage: TokenUsage


class CompletionRequestSerializer(BaseModel):
    model: str
    prompt: str
    params: CompletionParams


class ChatRequestSerializer(BaseModel):
    model: str
    messages: list[Message]
    params: ChatParams


class RoleDeserializer(BaseModel):
    role: str


CompletionRequestListSerializer = RootModel[list[CompletionRequest]]


CompletionListDeserializer = RootModel[list[Completion]]


ChatRequestListSerializer = RootModel[list[ChatRequest]]


ChatListDeserializer = RootModel[list[ChatResponse]]


ExplanationRequestListSerializer = RootModel[list[ExplanationRequest]]


ExplanationListDeserializer = RootModel[list[list[TextScore]]]
